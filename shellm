#!/usr/bin/env bash
#shopt -s nullglob globstar
#set -o pipefail
# Default Variables
API_URL="${API_URL:-http://localhost:11434/api}"  # Read API_URL from environment or use default
MODEL_SMALL="${MODEL_SMALL:-qwen2.5:3b-instruct-q5_K_M}"  # Read API_URL from environment or use default
NUM_PREDICT=500  # Default number of predictions
VERBOSE=2  # Default Errors, Warnings and Tools
USE_TOOL=0
SCRIPT_PATH=$(dirname $(realpath -s $0))
# Global associative array for tools
declare -A TOOLS=()
PROMPT_FRAGMENT_AGENT=""
# Global variables for system prompts
SYSTEM_PROMPT_INSTRUCT="You are Shellm, an intelligent AI assistant designed to process user requests with accuracy and efficiency. Your goal is to provide informative and context-aware responses."

SYSTEM_PROMPT_TOOL='You are a highly intelligent agent responsible for selecting and configuring tools based on user instructions.

You are embedded in an application that allows you to
* modify files
* execute code
* access the internet
* much, much more

Your mission is to analyze tasks thoroughly and create an effective series of tool calls to deliver optimal results.
You may reuse tools in various configurations to ensure the best outcome.
Break down tasks into manageable steps, utilizing multiple tools and crafting a coherent toolchain.
You are not alone! Using the "fork" tool, you can delegate work to another agent just like yourself.
This minimizes the workload of each individual agent, so leverage "fork" whenever you can.


# Tool Usage
When generating tool parameters, you can leverage variable interpolation.
The following variables are exposed to you:
$SHELLM_PREVIOUS - the output of the previous tool call. Use this to post-process output in subsequent tool calls.
$SHELLM_OUTPUT - the entire output buffer, ie. what the user sees.
$PROMPT - the initial instructions of the user.



# Interacting with the user

Only the "say" tool outputs results to the user.
All other tools operate silently, with their outputs stored in \$SHELLM_PREVIOUS for further processing.
Therefore, leverage $SHELLM_PREVIOUS in function parameters to consume output from previous tools.
For example, in other to show the output of a shell command, it must be followed by a "say" tool call which has
$SHELLM_PREVIOUS as its "message".

## Example

This combination results in the LLM writing a poem about the current day, which is then presented to the user:
`
{"function":{"name":"get_current_day"}}
{"function":{"name":"generate","arguments":{"prompt":"Write a poem about $SHELLM_PREVIOUS."}}}
{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}
`
You MUST ALWAYS finish a toolchain with a "say" invocation that presents the result of your work.
You SHOULD prepare the final "say" invocation by letting the LLM create a human-friendly reply with the "generate" tool.
You are also encouraged to "say" status updates in longer toolchains.
'

SYSTEM_PROMPT_TOOL_CONTEXT='You are a highly intelligent agent responsible for analyzing and interpreting user input.
You are embedded in an application that allows you to
* modify files
* execute code
* access the internet
* much, much more

You are sitting between the user and a tool calling AI agent. You are a planning expert capable of strategic long-term thinking.
Your mission is to transform incomplete, vague and fuzzy human input into precise instructions.
Identify missing or incomplete information.
Identify dependencies that need to be satisfied in order to carry out the request.
Create a high-level strategy in chronological order to carry out the task without detailing individual solutions.
Keep it declarative and let the AI agent pick the concrete tools.
Hold the prose. Bullet points only.
'

# Output variables
SHELLM_OUTPUT=""
SHELLM_PREVIOUS=""
SHELLM_ERROR=""

# Function for colored logging with severity levels
log() {
  local level="$1"; local message="\e[37m$(echo "$2" | tr '\n' ' ' )\e[0m"; local color
  case "$level" in
    debug) color="\e[33m[DEBUG]\e[0m" ;;
    tool) color="\e[36m[TOOL]\e[0m" ;;
    warning) color="\e[35m[WARNING]\e[0m" ;;
    error) color="\e[31m[ERROR]\e[0m" ;;
    *) color="\e[0m" ;;
  esac
  [[ $VERBOSE -gt 0 && "$level" == "error" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 1 && "$level" == "warning" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 2 && "$level" == "tool" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 3 && "$level" == "debug" ]] && echo -e "\n$color $message" >&2
}

# Function to escape input read from stdin
escape() {
  # Read from stdin
  local input
  input=$(cat)

  # Escape special characters only for command execution, not for user output
  local escaped_input
  escaped_input="${input//&/\\&}"  # Escape ampersands
  escaped_input="${escaped_input//\\/\\\\}"  # Escape backslashes
  escaped_input="${escaped_input//\/\x27}"  # Escape single quotes
  escaped_input="${escaped_input//\"/\\\"}"  # Escape double quotes
  escaped_input="${escaped_input//\`/\\\`}"  # Escape backticks
  echo "$escaped_input"
}

# Function to load tools from YAML file
load_tools() {
  local tool_paths=("$XDG_CONFIG_HOME/shellm/tools.yaml" "$HOME/.config/shellm/tools.yaml" "$HOME/tools.yaml" "$(dirname "$0")/tools.yaml")
  local merged_tools_json="{}"

  for path in "${tool_paths[@]}"; do
    [[ -f $path ]] && merged_tools_json=$(yq -s '.[0] * .[1]' <(echo "$merged_tools_json") "$path") && log debug "Loaded tools from $path"
  done

  IFS=$'\n'
  for tool in $(echo "$merged_tools_json" | jq -c 'to_entries[]'); do
    TOOLS["$(echo "$tool" | jq -r '.key')"]="$(echo "$tool" | jq -r '.value')"
  done
}

# Initialize the tools by loading them from the JSON file
load_tools

# Function to display usage
usage() {
  echo "Usage: $0 [-u api_url] [-m MODEL_SMALL] [-n num_predict] [-v] [-t] [prompt]"
  echo "  -u    API URL (default: $API_URL)"
  echo "  -m    Model name (default: $MODEL_SMALL)"
  echo "  -n    Number of predictions (default: $NUM_PREDICT)"
  echo "  -v    Verbose mode (show debug output)"
  echo "  -t    Activate tool use (uses generate_and_apply_tool_calls instead of generate_response)"
  echo "  prompt  Optional prompt (will be prepended if reading from stdin)"
  exit 1
}

# Function to generate a response from the model
generate_response() {
  local MODEL_SMALL="$1"
  local prompt="$2"
  local num_predict="$NUM_PREDICT"  # Fallback to global default if not set by -n
  local json_format=0  # Flag for JSON format

  # Parse options within generate_response
  while getopts ":n:j" opt; do
    case $opt in
      n) num_predict="$OPTARG" ;;  # Set num_predict from argument
      j) json_format=1 ;;          # Enable JSON format
      \?) log error "Invalid option: -$OPTARG"; usage ;;
      :) log error "Option -$OPTARG requires an argument."; usage ;;
    esac
  done

  shift $((OPTIND - 1))

  # Escape the prompt and system prompt for JSON
  local escaped_prompt
  escaped_prompt=$(echo "$prompt" | jq -Rsa .)
  escaped_system_prompt=$(echo "$SYSTEM_PROMPT_INSTRUCT" | jq -Rsa .)
  log debug "Escaped prompt for JSON: $escaped_prompt"

  # Add "format": "json" if -j flag was set
  local options
  options="{\"num_predict\": $num_predict, \"num_ctx\": 4096"
  [[ $json_format -eq 1 ]] && options+=", \"format\": \"json\""
  options+="}"

  # Capture the output of the streaming request into SHELLM_OUTPUT
  curl -sN "$API_URL/generate" \
    -d "{\"model\": \"$MODEL_SMALL\", \"system\": $escaped_system_prompt, \"prompt\": $escaped_prompt, \"stream\": true, \"options\": $options }" | \
    stdbuf -o0 jq -j '.response // empty' | escape
  echo ""
}

generate_tool_calls() {
  local MODEL_SMALL="$1"
  local prompt="$2"

  log tool "Generating toolchain based on prompt: $prompt"

  local escaped_prompt
  escaped_prompt=$(echo "$SYSTEM_PROMPT_TOOL\n# Current Task\n$prompt" | jq -Rsa .)

  # Construct the system message
  local system_message
  system_message=$(jq -n --arg content "$SYSTEM_PROMPT_TOOL" '{role: "system", content: $content}')

  # Construct the tools JSON using jq
  local tools_json
  tools_json=$(printf "%s" "${TOOLS[@]}" | jq -s .)

  # Construct the API payload
  local payload
  payload=$(jq -n --arg model "$MODEL_SMALL" --argjson messages "[${system_message}, {\"role\": \"user\", \"content\": $escaped_prompt}]" --argjson tools "$tools_json" \
        '{model: $model, messages: $messages, stream: false, tools: $tools}')

  # Make the API call and capture the response
  local response
  response=$(curl -s "$API_URL/chat" -d "$payload")
  log debug "Response: ${response}"

  # Extract tool_calls from the response using jq
  local tool_calls
  tool_calls=$(echo "$response" | jq -c '.message.tool_calls // []')

  # Convert tool_calls to a newline-separated list for proper handling
  echo "$tool_calls" | jq -c '.[]'
}

# Apply a list of tool call definitions
# Assuming you have a list of tool calls in JSON format, you can pass them directly to apply_tool_calls.
# For example:
#
# tool_calls=(
#   '{"function":{"name":"get_current_day"}}'
#   '{"function":{"name":"generate","arguments":{"prompt":"Please write a poem about $SHELLM_PREVIOUS."}}}'
#   '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
# )
#
# apply_tool_calls "${tool_calls[@]}"
#
apply_tool_calls() {
  local tool_calls_array=("$@")
  for tool_call in "${tool_calls_array[@]}"; do
    log debug "Processing tool_call $tool_call"
    local tool_name
    tool_name=$(echo "$tool_call" | jq -r '.function.name')

    # Fetch the corresponding tool definition
    local tool_def="${TOOLS[$tool_name]}"
    log tool "Calling '$tool_name'"
    if [ -z "$tool_def" ]; then
      log error "Error: Tool '$tool_name' not found in TOOLS array."
      continue
    fi

    # Fetch the 'exec' command template
    local exec_cmd_template
    exec_cmd_template=$(echo "$tool_def" | jq -r '.function.exec')

    # Interpolate parameters from tool_call into the exec command
    local interpolated_cmd="$exec_cmd_template"
    local parameters
    parameters=$(echo "$tool_call" | jq -c '.function.arguments // {}')

    # Iterate over each parameter and replace placeholders in the command
    for param in $(echo "$parameters" | jq -r 'keys[]'); do
      local value
      value=$(echo "$parameters" | jq -r --arg param "$param" '.[$param]')

      # Check if escaping is required
      local raw
      raw=$(echo "$tool_def" | jq -r --arg param "$param" '.function.parameters.properties[$param].raw // false')
      log debug "Parameter: $param, Value: $value, Raw: $raw"
      value="${value//&/\\&}"  # Escape ampersands
      # Conditionally escape or pass as-is based on the "escape" field
      if [[ ! "$raw" == "true" ]]; then
        log debug "Escaping parameter: $param"
        value="$(echo "$value" | escape)"

      fi

      interpolated_cmd="${interpolated_cmd//\$\{$param\}/$value}"
    done

    # Interpolate SHELLM_PREVIOUS and SHELLM_OUTPUT into the command
    interpolated_cmd=${interpolated_cmd//\$SHELLM_PREVIOUS/$SHELLM_PREVIOUS}
    interpolated_cmd=${interpolated_cmd//\$SHELLM_OUTPUT/$SHELLM_OUTPUT}

    log tool "Executing command: $interpolated_cmd"

    # Execute the interpolated command, capturing all details
    exit_code=0

    # Use a subshell to redirect stdout and stderr
    {
      SHELLM_PREVIOUS=$(eval "$interpolated_cmd")
      exit_code=$?
    } 2> >(SHELLM_ERROR=$(cat) >&2)

    log tool "Exit: $exit_code"

    # Check for a nonzero exit code and echo errors if present
    if [[ $exit_code -ne 0 ]]; then
      log error "Command '$interpolated_cmd' failed with exit code $exit_code."
      log error "$SHELLM_ERROR"
      # TODO Consider recursion with a fresh prompt to allow the agent to try again
      exit 1
    else
      log tool "Result: $SHELLM_PREVIOUS"
    fi

    # If the tool is "say", echo its output to the terminal
    if [ "$tool_name" == "say" ]; then
      printf '%s' "$SHELLM_PREVIOUS"
      SHELLM_OUTPUT+=$SHELLM_PREVIOUS
    fi
  done
}

# Generate a toolchain based on a prompt. Then immediately apply it
generate_and_apply_tool_calls() {
  local MODEL_SMALL="$1"; local prompt="$2"
  local tool_calls_array=($(generate_tool_calls "$MODEL_SMALL" "$prompt"))
  apply_tool_calls "${tool_calls_array[@]}"
}
# Parse command line options
while getopts ":u:m:n:v:th" opt; do
  case $opt in
    u) API_URL="$OPTARG" ;;
    m) MODEL_SMALL="$OPTARG" ;;
    n) NUM_PREDICT="$OPTARG" ;;
    v) VERBOSE="$OPTARG" ;;  # Set verbose mode
    t) USE_TOOL=1 ;;  # Set tool use flag
    h) usage ;;
    \?) log error "Invalid option: -$OPTARG"; usage ;;
    :) log error "Option -$OPTARG requires an argument."; usage ;;
  esac
done

# Determine execution path based on arguments
shift $((OPTIND - 1))
if [[ $# -eq 2 ]]; then
  FUNC="$1"; shift
  type "$FUNC" &>/dev/null && "$FUNC" "$@" || { log error "Function '$FUNC' not found"; exit 1; }
fi

# Handle the prompt as a positional argument
PROMPT="$*"

# If input is provided via stdin, prepend the optional prompt
if [ ! -t 0 ]; then
  STDIN_INPUT=$(cat)
  PROMPT="${PROMPT}${PROMPT:+ }${STDIN_INPUT}"
fi

# Default prompt if none was provided
PROMPT="${PROMPT:-Why is the sky blue? Write a short markdown document}"

log debug "Calling $API_URL with $MODEL_SMALL requesting $NUM_PREDICT tokens"
log debug "Final prompt: $PROMPT"

# Function to check if the model exists
check_model_exists() {
  local model_check
  log debug "Checking if model $MODEL_SMALL exists on API server..."
  model_check=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/show" -d "{\"model\": \"$MODEL_SMALL\"}")

  if [[ "$model_check" == "200" ]]; then
    log debug "Model $MODEL_SMALL exists."
    return 0
  else
    log warning "Model $MODEL_SMALL does not exist. Attempting to pull..."
    return 1
  fi
}

# Function to pull the model
pull_model() {
  local pull_response
  log debug "Attempting to pull model $MODEL_SMALL..."
  pull_response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/pull" -d "{\"model\": \"$MODEL_SMALL\", \"stream\": false}")

  if [[ "$pull_response" == "200" ]]; then
    log debug "Successfully pulled model $MODEL_SMALL."
  else
    log error "Error pulling model $MODEL_SMALL. HTTP Status: $pull_response"
    exit 1
  fi
}

# Function to gather system information
gather_system_info() {
  local terminal_info
  local os_info

  # Gather terminal, hostname, and OS type information
  terminal_info=$(echo "$TERM")
  os_info=$(uname -s)  # Get the OS type

  # Create a formatted output
  echo "Terminal: $terminal_info\nOS Type: $os_info"
}

tool_calls=(
   '{"function":{"name":"while","arguments":{"predicate":"The joke was considered funny","tools":[{"function":{"name":"say","arguments":{"message":"Hi"}}}]}}}'
 )

 apply_tool_calls "${tool_calls[@]}"
exit
# Check if the model exists, if not, pull it
if ! check_model_exists; then
  pull_model
fi

# Call the appropriate function based on tool usage
if [ "$USE_TOOL" -eq 1 ]; then
   escaped_system_prompt=$(echo "$SYSTEM_PROMPT_TOOL_CONTEXT\n\nSystem Info:\n$(gather_system_info)\n\nUser request\n:$PROMPT" | jq -Rsa .)
   tool_calls=(
     '{"function":{"name":"generate","arguments":{"prompt":"Create a concise title and subtitle that summarize the following task: '$PROMPT'"}}}'
     '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
     '{"function":{"name":"generate","arguments":{"prompt":'$escaped_system_prompt'}}}'
     '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
   )

  apply_tool_calls "${tool_calls[@]}"
  generate_and_apply_tool_calls "$MODEL_SMALL" 'The request of the user is "'$PROMPT'"\n# Execution plan\n'$SHELLM_PREVIOUS'\n'
  tool_calls=(
    '{"function":{"name":"generate","arguments":{"prompt":"$SHELLM_OUTPUT\n## Summary:\n"}}}'
    '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
  )
  apply_tool_calls "${tool_calls[@]}"
  exit
else
  generate_response "$MODEL_SMALL" "$PROMPT" "$NUM_PREDICT"
fi
