#!/usr/bin/env bash
#shopt -s nullglob globstar
#set -o pipefail
# Default Variables
API_URL="${API_URL:-http://localhost:11434/api}"  # Read API_URL from environment or use default
MODEL_SMALL="${MODEL_SMALL:-qwen2.5:3b-instruct-q5_K_M}"  # Read API_URL from environment or use default
NUM_PREDICT=500  # Default number of predictions
VERBOSE=2  # Default Errors, Warnings and Tools
USE_TOOL=0
# Global associative array for tools
declare -A TOOLS=()

# Global variables for system prompts
SYSTEM_PROMPT_INSTRUCT="You are Shellm, an intelligent AI assistant designed to process user requests with accuracy and efficiency. Your goal is to provide informative and context-aware responses."

SYSTEM_PROMPT_TOOL='You are a highly intelligent agent responsible for selecting and configuring tools based on user instructions.
Your mission is to analyze tasks thoroughly and create an effective series of tool calls to deliver optimal results.
Break down tasks into manageable steps, utilizing multiple tools and crafting a coherent toolchain.
You may reuse tools in various configurations to ensure the best outcome.


# Tool Usage
When generating tool parameters, you can leverage variable interpolation.
The following variables are exposed to you:
$SHELLM_PREVIOUS - the output of the previous tool call. Use this to post-process output in subsequent tool calls.
$SHELLM_OUTPUT - the entire output buffer, ie. what the user sees.
$PROMPT - the initial instructions of the user.



# Interacting with the user

Only the "say" tool outputs results to the user.
All other tools operate silently, with their outputs stored in \$SHELLM_PREVIOUS for further processing.
Therefore, leverage $SHELLM_PREVIOUS in function parameters to consume output from previous tools.
For example, in other to show the output of a shell command, it must be followed by a "say" tool call which has
$SHELLM_PREVIOUS as its "message".

## Example

This combination results in the LLM writing a poem about the current day, which is then presented to the user:
`
{"function":{"name":"get_current_day"}}
{"function":{"name":"generate","arguments":{"prompt":"Write a poem about $SHELLM_PREVIOUS."}}}
{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}
`
You MUST ALWAYS finish a toolchain with a "say" invocation that presents the result of your work.
You SHOULD prepare the final "say" invocation by letting the LLM create a human-friendly reply with the "generate" tool.
You are also encouraged to "say" status updates in longer toolchains.
'

# Output variables
SHELLM_OUTPUT=""
SHELLM_PREVIOUS=""
SHELLM_ERROR=""

# Function for colored logging with severity levels
log() {
  local level="$1"; local message="\e[37m$(echo "$2" | tr '\n' ' ' | cut -c1-500)\e[0m"; local color
  case "$level" in
    debug) color="\e[33m[DEBUG]\e[0m" ;;
    tool) color="\e[36m[TOOL]\e[0m" ;;
    warning) color="\e[35m[WARNING]\e[0m" ;;
    error) color="\e[31m[ERROR]\e[0m" ;;
    *) color="\e[0m" ;;
  esac
  [[ $VERBOSE -gt 1 && "$level" == "warning" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 2 && "$level" == "tool" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 3 && "$level" == "debug" ]] && echo -e "\n$color $message" >&2
}

# Function to load tools from JSON file
load_tools() {
  local tool_paths=("$XDG_CONFIG_HOME/shellm/tools.json" "$HOME/.config/shellm/tools.json" "$HOME/tools.json" "$(dirname "$0")/tools.json")
  local merged_tools_json="{}"

  for path in "${tool_paths[@]}"; do
    [[ -f $path ]] && merged_tools_json=$(jq -s '.[0] * .[1]' <(echo "$merged_tools_json") "$path") && log debug "Loaded tools from $path"
  done

  IFS=$'\n'
  for tool in $(echo "$merged_tools_json" | jq -c 'to_entries[]'); do
    TOOLS["$(echo "$tool" | jq -r '.key')"]="$(echo "$tool" | jq -r '.value')"
  done
}

# Initialize the tools by loading them from the JSON file
load_tools

# Function to display usage
usage() {
  echo "Usage: $0 [-u api_url] [-m MODEL_SMALL] [-n num_predict] [-v] [-t] [prompt]"
  echo "  -u    API URL (default: $API_URL)"
  echo "  -m    Model name (default: $MODEL_SMALL)"
  echo "  -n    Number of predictions (default: $NUM_PREDICT)"
  echo "  -v    Verbose mode (show debug output)"
  echo "  -t    Activate tool use (uses generate_and_apply_tool_calls instead of generate_response)"
  echo "  prompt  Optional prompt (will be prepended if reading from stdin)"
  exit 1
}

# Function to generate a response from the model
generate_response() {
  local MODEL_SMALL="$1"
  local prompt="$2"
  local num_predict="$3"

  log debug "Generating via $MODEL_SMALL, Prompt: $prompt, Num Predict: $num_predict"

  local escaped_prompt
  escaped_prompt=$(echo "$prompt" | jq -Rsa .)
  escaped_system_prompt=$(echo "$SYSTEM_PROMPT_INSTRUCT" | jq -Rsa .)
  log debug "Escaped prompt for JSON: $escaped_prompt"

  # Capture the output of the streaming request into SHELLM_OUTPUT while streaming it
  curl -sN "$API_URL/generate" \
    -d "{\"model\": \"$MODEL_SMALL\", \"system\": $escaped_system_prompt, \"prompt\": $escaped_prompt, \"stream\": true, \"options\": { \"num_predict\": $num_predict, \"num_ctx\": 4096 } }" | \
    stdbuf -o0 jq -j '.response // empty'
}

generate_tool_calls() {
  local MODEL_SMALL="$1"
  local prompt="$2"

  log tool "Generating toolchain based on prompt: $prompt"

  local escaped_prompt
  escaped_prompt=$(echo "$SYSTEM_PROMPT_TOOL\n# Current Task\n$prompt" | jq -Rsa .)

  # Construct the system message
  local system_message
  system_message=$(jq -n --arg content "$SYSTEM_PROMPT_TOOL" '{role: "system", content: $content}')

  # Construct the tools JSON using jq
  local tools_json
  tools_json=$(printf "%s" "${TOOLS[@]}" | jq -s .)

  # Construct the API payload
  local payload
  payload=$(jq -n --arg model "$MODEL_SMALL" --argjson messages "[${system_message}, {\"role\": \"user\", \"content\": $escaped_prompt}]" --argjson tools "$tools_json" \
        '{model: $model, messages: $messages, stream: false, tools: $tools}')

  # Make the API call and capture the response
  local response
  response=$(curl -s "$API_URL/chat" -d "$payload")
  log debug "Response: ${response}"

  # Extract tool_calls from the response using jq
  local tool_calls
  tool_calls=$(echo "$response" | jq -c '.message.tool_calls // []')

  # Convert tool_calls to a newline-separated list for proper handling
  echo "$tool_calls" | jq -c '.[]'
}

# Apply a list of tool call definitions
# Assuming you have a list of tool calls in JSON format, you can pass them directly to apply_tool_calls.
# For example:
#
# tool_calls=(
#   '{"function":{"name":"get_current_day"}}'
#   '{"function":{"name":"generate","arguments":{"prompt":"Please write a poem about $SHELLM_PREVIOUS."}}}'
#   '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
# )
#
# apply_tool_calls "${tool_calls[@]}"
#
apply_tool_calls() {
  local tool_calls_array=("$@")
  for tool_call in "${tool_calls_array[@]}"; do
    log debug "Processing tool_call $tool_call"
    local tool_name
    tool_name=$(echo "$tool_call" | jq -r '.function.name')

    # Fetch the corresponding tool definition
    local tool_def="${TOOLS[$tool_name]}"
    log tool "Calling '$tool_name'"
    if [ -z "$tool_def" ]; then
      log error "Error: Tool '$tool_name' not found in TOOLS array."
      continue
    fi

    # Fetch the 'exec' command template
    local exec_cmd_template
    exec_cmd_template=$(echo "$tool_def" | jq -r '.function.exec')

    # Interpolate parameters from tool_call into the exec command
    local interpolated_cmd="$exec_cmd_template"
    local parameters
    parameters=$(echo "$tool_call" | jq -c '.function.arguments // {}')

    # Iterate over each parameter and replace placeholders in the command
    for param in $(echo "$parameters" | jq -r 'keys[]'); do
      local value
      value=$(echo "$parameters" | jq -r --arg param "$param" '.[$param]')

      # Check if escaping is required
      local raw
      raw=$(echo "$tool_def" | jq -r --arg param "$param" '.function.parameters.properties[$param].raw // false')
      log tool "Parameter: $param, Value: $value, Escape: $raw"
      value="${value//&/\\&}"  # Escape ampersands
      # Conditionally escape or pass as-is based on the "escape" field
      if [[ ! "$raw" == "true" ]]; then
        log tool "Escaping parameter: $param"
        value="${value//\'/\'\"\'\"\'}"  # Escape single quotes
        value="${value//\`/\\\`}"        # Escape backticks
      fi

      interpolated_cmd="${interpolated_cmd//\$\{$param\}/$value}"
    done

    # Interpolate SHELLM_PREVIOUS and SHELLM_OUTPUT into the command
    interpolated_cmd=${interpolated_cmd//\$SHELLM_PREVIOUS/$SHELLM_PREVIOUS}
    interpolated_cmd=${interpolated_cmd//\$SHELLM_OUTPUT/$SHELLM_OUTPUT}

    log tool "Executing command: $interpolated_cmd"

    # Execute the interpolated command, capturing all details
    # Kudos to madmurphy over at https://stackoverflow.com/a/59592881
    local exit_code
    {
        IFS=$'\n' read -r -d '' SHELLM_PREVIOUS;
        IFS=$'\n' read -r -d '' SHELLM_ERROR;
        (IFS=$'\n' read -r -d '' exit_code; return ${_ERRNO_});
    } < <((printf '\0%s\0%d\0' "$(((({ eval "$interpolated_cmd"; echo "${?}" 1>&3-; } | tr -d '\0' 1>&4-) 4>&2- 2>&1- | tr -d '\0' 1>&4-) 3>&1- | exit "$(cat)") 4>&1-)" "${?}" 1>&2) 2>&1)

    # Check for a nonzero exit code and echo errors if present
    if [[ $exit_code -ne 0 ]]; then
      log error "Command '$interpolated_cmd' failed with exit code $exit_code."
      echo "$SHELLM_ERROR" >&2
    else
      log tool "Result: $SHELLM_PREVIOUS"
    fi

    # If the tool is "say", echo its output to the terminal
    if [ "$tool_name" == "say" ]; then
      echo -n "$SHELLM_PREVIOUS"
      SHELLM_OUTPUT+=$SHELLM_PREVIOUS
    fi
  done
}

# Generate a toolchain based on a prompt. Then immediately apply it
generate_and_apply_tool_calls() {
  local MODEL_SMALL="$1"; local prompt="$2"
  local tool_calls_array=($(generate_tool_calls "$MODEL_SMALL" "$prompt"))
  apply_tool_calls "${tool_calls_array[@]}"
}
# Parse command line options
while getopts ":u:m:n:v:th" opt; do
  case $opt in
    u) API_URL="$OPTARG" ;;
    m) MODEL_SMALL="$OPTARG" ;;
    n) NUM_PREDICT="$OPTARG" ;;
    v) VERBOSE="$OPTARG" ;;  # Set verbose mode
    t) USE_TOOL=1 ;;  # Set tool use flag
    h) usage ;;
    \?) log error "Invalid option: -$OPTARG"; usage ;;
    :) log error "Option -$OPTARG requires an argument."; usage ;;
  esac
done

# Shift the parsed options away, so only positional arguments remain
shift $((OPTIND - 1))

# Handle the prompt as a positional argument
PROMPT="$*"

# If input is provided via stdin, prepend the optional prompt
if [ ! -t 0 ]; then
  STDIN_INPUT=$(cat)
  PROMPT="${PROMPT}${PROMPT:+ }${STDIN_INPUT}"
fi

# Default prompt if none was provided
PROMPT="${PROMPT:-Why is the sky blue? Write a short markdown document}"

log debug "Calling $API_URL with $MODEL_SMALL requesting $NUM_PREDICT tokens"
log debug "Final prompt: $PROMPT"

# Function to check if the model exists
check_model_exists() {
  local model_check
  log debug "Checking if model $MODEL_SMALL exists on API server..."
  model_check=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/show" -d "{\"model\": \"$MODEL_SMALL\"}")

  if [[ "$model_check" == "200" ]]; then
    log debug "Model $MODEL_SMALL exists."
    return 0
  else
    log warning "Model $MODEL_SMALL does not exist. Attempting to pull..."
    return 1
  fi
}

# Function to pull the model
pull_model() {
  local pull_response
  log debug "Attempting to pull model $MODEL_SMALL..."
  pull_response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/pull" -d "{\"model\": \"$MODEL_SMALL\", \"stream\": false}")

  if [[ "$pull_response" == "200" ]]; then
    log debug "Successfully pulled model $MODEL_SMALL."
  else
    log error "Error pulling model $MODEL_SMALL. HTTP Status: $pull_response"
    exit 1
  fi
}

# Check if the model exists, if not, pull it
if ! check_model_exists; then
  pull_model
fi

#tool_calls=(
#  '{"function":{"name":"execute_shell_command","arguments":{"command":"echo LOL 1>&2; exit 1 "}}}'
#)
#apply_tool_calls "${tool_calls[@]}"
#exit
# Call the appropriate function based on tool usage
if [ "$USE_TOOL" -eq 1 ]; then
   tool_calls=(
     '{"function":{"name":"generate","arguments":{"prompt":"Create a concise title and subtitle that summarize the following task: '$PROMPT'"}}}'
     '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
     '{"function":{"name":"generate","arguments":{"prompt":"Mirror and interpret the request and briefly state that you will proceed to work on a plan without giving details. Task: '$PROMPT'"}}}'
     '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
     '{"function":{"name":"generate","arguments":{"prompt":"Prepare concise instructions for a tool-calling AI agent. Summarize the context and outline a high-level strategy to address the following request without detailing specific tools: '$PROMPT'"}}}'
     '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
   )

  apply_tool_calls "${tool_calls[@]}"
  generate_and_apply_tool_calls "$MODEL_SMALL" 'The request of the user is "'$PROMPT'"\n# Execution plan\n'$SHELLM_PREVIOUS'\n'
  tool_calls=(
    '{"function":{"name":"generate","arguments":{"prompt":"$SHELLM_OUTPUT\n## Summary:\n"}}}'
    '{"function":{"name":"say","arguments":{"message":"$SHELLM_PREVIOUS"}}}'
  )
  apply_tool_calls "${tool_calls[@]}"
  exit
else
  generate_response "$MODEL_SMALL" "$PROMPT" "$NUM_PREDICT"
fi
