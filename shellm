#!/usr/bin/env bash
# shellcheck disable=SC2155
#shopt -s nullglob globstar
#set -o pipefail
#set -x
# Default Variables
API_URL="${API_URL:-http://localhost:11434/api}"  # Read API_URL from environment or use default
SHELLM_MODEL="${SHELLM_MODEL:-qwen2.5:3b-instruct-q5_K_M}"  # Rename MODEL_SMALL to SHELLM_MODEL
NUM_PREDICT=500  # Default number of predictions
VERBOSE=0  # Default Errors, Warnings
SCRIPT_PATH=$(dirname "$(realpath -s "$0")")

# Output variables
SHELLM_OUTPUT=""
SHELLM_PREVIOUS=""
SHELLM_ERROR=""

# Function for colored logging with severity levels
log() {
  local level="$1"; local message="\e[37m$(echo "$2" | tr '\n' ' ' )\e[0m"; local color
  case "$level" in
    debug) color="\e[33m[DEBUG]\e[0m" ;;
    warning) color="\e[35m[WARNING]\e[0m" ;;
    error) color="\e[31m[ERROR]\e[0m" ;;
    *) color="\e[0m" ;;
  esac
  [[ $VERBOSE -gt 0 && "$level" == "error" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 1 && "$level" == "warning" ]] && echo -e "\n$color $message" >&2
  [[ $VERBOSE -gt 3 && "$level" == "debug" ]] && echo -e "\n$color $message" >&2
}

# Function to escape input read from stdin
escape() {
  # Read from stdin
  local input
  input=$(cat)

  # Escape special characters only for command execution, not for user output
  local escaped_input
  escaped_input="${input//&/\\&}"  # Escape ampersands
  escaped_input="${escaped_input//\\/\\\\}"  # Escape backslashes
  escaped_input="${escaped_input//\/\x27}"  # Escape single quotes
  escaped_input="${escaped_input//\"/\\\"}"  # Escape double quotes
  escaped_input="${escaped_input//\`/\\\`}"  # Escape backticks
  echo "$escaped_input"
}

# Function to display usage
usage() {
  echo "Usage: $0 [-u api_url] [-m SHELLM_MODEL] [-n num_predict] [-v 0-2] [prompt]"
  echo "  -u    API URL (default: $API_URL)"
  echo "  -m    Model name (default: $SHELLM_MODEL)"
  echo "  -n    Number of predictions (default: $NUM_PREDICT)"
  echo "  -v    Verbosity mode (Specify log level from 0-2)"
  echo "  prompt  Optional prompt (will be prepended if reading from stdin)"
  exit 1
}

# Function to generate a response from the model
generate_response() {
  log debug "generate_response"

  local num_predict="$NUM_PREDICT"
  local json_format=0  # Flag for JSON format
  local prompt=$(echo "$1" | jq -Rsa .)

  log debug "User prompt: $prompt"

  # Escape the prompt and system prompt for JSON
  local system=""
  if [ $json_format -eq 1 ]; then
    system+="\n
        You MUST return a JSON object with the following structure:
        { \"result\": <VALUE> }

        Examples:
        Input: Is the sky blue?
        Output: { \"result\": true }

        Input: Write a number between 1 and 50
        Output: { \"result\": 36 }

        Input: Name an animal
        Output: { \"result\": \"cow\" }
    "
  fi
  system=$(echo "$system" | jq -Rsa .)
  log debug "System prompt: $system"

  options=$(jq -n \
    --arg num_predict "$num_predict" \
    --arg num_ctx 4096 \
    --arg json_format "$json_format" \
    '{
      num_predict: $num_predict|tonumber,
      num_ctx: $num_ctx|tonumber
    } + if $json_format == 1 then {format: "json"} else {} end' \
  )
  log debug "Options: $options"

  # Construct the API payload
  local payload=$(jq -n \
  --arg model "$SHELLM_MODEL" \
  --arg system "$system" \
  --arg prompt "$prompt" \
  --argjson options "$options" \
  '{model: $model, system: $system, prompt: $prompt, options: $options, stream: true}' \
  )
  # Capture the output of the streaming request into SHELLM_OUTPUT
  curl -sN "$API_URL/generate" \
    -d "$payload" | \
    stdbuf -o0 jq -j '.response // empty'
  echo ""
}

# Parse command line options
while getopts ":u:m:n:v:h" opt; do
  case $opt in
    u) API_URL="$OPTARG" ;;
    m) SHELLM_MODEL="$OPTARG" ;;
    n) NUM_PREDICT="$OPTARG" ;;
    v) VERBOSE="$OPTARG" ;;  # Set verbose mode
    h) usage ;;
    \?) log error "Invalid option: -$OPTARG"; usage ;;
    :) log error "Option -$OPTARG requires an argument."; usage ;;
  esac
done
shift $((OPTIND-1))

# Handle the prompt as a positional argument
PROMPT="$1"

# If input is provided via stdin, prepend the optional prompt
if [ ! -t 0 ]; then
  STDIN_INPUT=$(cat)
  PROMPT="${PROMPT}${PROMPT:+ }${STDIN_INPUT}"
fi

# Check if the prompt is empty and exit with an error message if it is empty
if [ -z "$PROMPT" ]; then
  log error "No prompt provided. Please provide a prompt as an argument or via stdin."
  exit 1
fi

log debug "Calling $API_URL with $MODEL_SMALL requesting $NUM_PREDICT tokens"

# Function to check if the model exists
check_model_exists() {
  local model_check
  log debug "Checking if model $SHELLM_MODEL exists on API server..."
  model_check=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/show" -d "{\"model\": \"$SHELLM_MODEL\"}")

  if [[ "$model_check" == "200" ]]; then
    log debug "Model $SHELLM_MODEL exists."
    return 0
  else
    log warning "Model $SHELLM_MODEL does not exist. Attempting to pull..."
    return 1
  fi
}

# Function to pull the model
pull_model() {
  local pull_response
  log debug "Attempting to pull model $SHELLM_MODEL..."
  pull_response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/pull" -d "{\"model\": \"$SHELLM_MODEL\", \"stream\": false}")

  if [[ "$pull_response" == "200" ]]; then
    log debug "Successfully pulled model $SHELLM_MODEL."
  else
    log error "Error pulling model $SHELLM_MODEL. HTTP Status: $pull_response"
    exit 1
  fi
}

# Check if the model exists, if not, pull it
if ! check_model_exists; then
  pull_model
fi

generate_response "$PROMPT"